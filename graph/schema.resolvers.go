package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"graphql/graph/generated"
	"graphql/graph/model"
	"log"
	"strings"
)

// CreateStaff creates a new staff member using the NewStaffInput.
func (r *mutationResolver) CreateStaff(ctx context.Context, input model.NewStaffInput) (*model.Staff, error) {
	staff := &model.Staff{
		FirstName:  input.FirstName,
		LastName:   input.LastName,
		Email:      input.Email,
		Role:       input.Role,
		Department: input.Department,
		Salary:     input.Salary,
	}

	err := r.DB.CreateStaff(staff)
	if err != nil {
		return nil, err
	}
	return staff, nil
}

// AssignProjectToStaff assigns a project to a specific staff member.
func (r *mutationResolver) AssignProjectToStaff(ctx context.Context, staffID string, projectID string) (*model.Project, error) {
	project, err := r.DB.AssignProjectToStaff(staffID, projectID)
	if err != nil {
		return nil, err // Return error if project assignment fails
	}
	return project, nil
}

func (r *queryResolver) ListAllStaff(ctx context.Context, filter *model.StaffFilter, sortBy *model.SortBy, order *model.Order, pagination *model.Pagination) ([]*model.Staff, error) {
	if r.DB == nil {
		log.Println("DB connection is nil")
		return nil, fmt.Errorf("database connection is not initialized")
	}

	// Initialize the base query and argument list
	var query = "SELECT id, first_name, last_name, email, role, department, salary FROM staff"
	var args []interface{}

	// Apply filter logic
	if filter != nil {
		var whereClauses []string

		// Check if the Role is provided (not nil) and add it to the WHERE clause
		if filter.Role != nil && *filter.Role != "" {
			whereClauses = append(whereClauses, "role = ?")
			args = append(args, *filter.Role)
		}

		// Check if the Department is provided (not nil) and add it to the WHERE clause
		if filter.Department != nil && *filter.Department != "" {
			whereClauses = append(whereClauses, "department = ?")
			args = append(args, *filter.Department)
		}

		// Check if the SalaryMin is provided (greater than 0) and add it to the WHERE clause
		if filter.SalaryMin != nil && *filter.SalaryMin > 0 {
			whereClauses = append(whereClauses, "salary >= ?")
			args = append(args, *filter.SalaryMin)
		}

		// Check if the SalaryMax is provided (greater than 0) and add it to the WHERE clause
		if filter.SalaryMax != nil && *filter.SalaryMax > 0 {
			whereClauses = append(whereClauses, "salary <= ?")
			args = append(args, *filter.SalaryMax)
		}

		// If any conditions are added, join them with "AND" and apply to query
		if len(whereClauses) > 0 {
			query += " WHERE " + strings.Join(whereClauses, " AND ")
		}
	}

	// Sorting logic
	if sortBy != nil {
		switch *sortBy {
		case model.SortByFirstName:
			query += " ORDER BY first_name"
		case model.SortByLastName:
			query += " ORDER BY last_name"
		case model.SortByRole:
			query += " ORDER BY role"
		case model.SortBySalary:
			query += " ORDER BY salary"
		default:
			query += " ORDER BY first_name" // Default sorting if none specified
		}
	}

	// Apply order (ASC/DESC)
	if order != nil {
		switch *order {
		case model.OrderAsc:
			query += " ASC"
		case model.OrderDesc:
			query += " DESC"
		default:
			query += " ASC" // Default order is ascending
		}
	}

	// Apply pagination
	if pagination != nil {
		// Ensure that page and limit have valid values
		if *pagination.Page < 1 {
			*pagination.Page = 1 // Ensure pagination starts from page 1
		}
		if *pagination.Limit < 1 {
			*pagination.Limit = 10 // Default to 10 items per page if not specified
		}

		// Apply the LIMIT and OFFSET for pagination
		query += fmt.Sprintf(" LIMIT %d OFFSET %d", *pagination.Limit, (*pagination.Page-1)*(*pagination.Limit))
	}

	// Execute the query
	rows, err := r.DB.Query(query, args...)
	if err != nil {
		log.Println("Error fetching staff data:", err)
		return nil, err
	}
	defer rows.Close()

	// Parse the results
	var staffList []*model.Staff
	for rows.Next() {
		var staff model.Staff
		err := rows.Scan(&staff.ID, &staff.FirstName, &staff.LastName, &staff.Email, &staff.Role, &staff.Department, &staff.Salary)
		if err != nil {
			log.Println("Error scanning staff data:", err)
			return nil, err
		}

		// Fetch projects for each staff member
		projects, err := r.DB.GetProjectsByStaffID(staff.ID)
		if err != nil {
			log.Println("Error fetching projects for staff:", err)
			return nil, err
		}
		staff.Projects = projects

		staffList = append(staffList, &staff)
	}

	// Check for errors after iterating over rows
	if err := rows.Err(); err != nil {
		log.Println("Error iterating over staff rows:", err)
		return nil, err
	}

	return staffList, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) GetStaffByID(ctx context.Context, id string) (*model.Staff, error) {
	return r.DB.GetStaffByID(id)
}
*/
